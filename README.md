# JAVA의 정석

## Chapter 1
- 자바에서 모든 코드는 반드시 클래스 안에 존재해야 한다.

## Chapter 2 변수
println()과 print()의 차이점
- println(): 줄바꿈 O
- print(): 줄바꿈 X

기본형과 참조형 변수
- 기본형 변수: 실제 값 저장(총 8개 타입)
- 참조형 변수: 메모리 주소를 저장(포인터)

참조형 변수
- `Date today = new Date();`
- Date는 클래스 이름(자료형), today는 변수명
- new는 객체를 생성하는 연산자, 그 결과는 생성된 객체의 주소

상수
- 값 변경 불가능
- `final int SEONGMIN_AGE = 25;`

## Chapter 3 연산자

## Chapter 4 조건문과 반복문

switch문에서
- 조건식은 결과값이 반드시 정수여야 한다.

## Chapter 5 배열

- 배열 선언 문법: `int[] scores = new int[5]`
- 배열 요소는 int의 기본값인 0으로 초기화 됨
- 배열 길이가 0일 수도 있음
- 배열은 한 번 생성하면 길이를 변경할 수 없음

char 배열과 String 클래스
- String 클래스는 기본적으로 char 배열인데 기능을 추가한 것임
- String 클래스는 내용 변경 불가능, char 배열은 내용 변경 가능

## Chapter 6 객체지향 프로그래밍 I

클래스
- 클래스는 객체를 정의한 것이다
- 클래스는 객체를 생성하는 데 사용된다

인스턴스
- 클래스로부터 객체를 만드는 과정을 클래스의 **인스턴스화**라고 한다
- 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스**라고 한다

객체
- 객체는 속성과 기능을 가진다
- 속성과 기능을 멤버라고 부른다
- 속성 = 멤버 변수
- 기능 = 메서드

변수의 종류
- 변수: 클래스 변수 + 인스턴스 변수 + 지역 변수
- 영역: 클래스 영역 + 메서드 영역
- 메서드 영역에 선언된 변수는 지역 변수
- 그 외의 모든 변수는 멤버 변수
- 멤버 변수 중 static이 붙은 것은 클래스 변수
- 멤버 변수 중 static이 붙지 않은 것은 인스턴스 변수

메서드를 사용하는 이유
1. 높은 재사용성
1. 중복된 코드의 제거
1. 프로그램의 구조화

매서드를 구현할 때 매개변수의 값이 적절한지 확인해야 한다. 호출하는 쪽에서 알아서 값을 넘겨주겠지라고 생각하지 말고 모든 경우의 수에 대비해야 한다.

JVM의 메모리 구조
1. 메서드 영역
  클래스에 대한 정보를 저장한다. 클래스 변수도 이 영역에 생성된다.
1. 힙
  인스턴스를 저장한다.
1. 호출 스택
  메서드 작업에 필요한 공간을 제공한다. 메서드가 종료되면 할당된 공간은 자동으로 반환된다.

매개변수의 종류
- 기본형 매개변수: 변수 값을 읽기만 할 수 있다(값 복사해서 전달)
- 참조형 매개변수: 변수 값을 읽고 변경할 수 있다(포인터 매개변수)

메서드의 종류
- 클래스 메서드: static 붙은 것. 객체 생성 없이 호출 가능
- 인스턴스 메서드: 객체를 생성해야 호출 가능
- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드
- 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드를 클래스 메서드로 정의

오버로딩
- 오버로딩: 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
- 오버로딩의 조건
  - 메서드 이름이 같아야 한다
  - 매개변수의 개수 또는 타입이 달라야 한다
  - 반환타입은 상관없다

가변인자
- 매개변수의 개수를 고정하지 않고 자유롭게 설정할 수 있다
- `public PrintStream printf(String format, Object... args) { ... }`
- 가변인자는 내부적으로 배열을 생성하므로 성능 문제를 고려해 꼭 필요한 경우에만 사용하자
- 가변인자와 배열 매개변수의 차이
  - 가변인자는 생략할 수 있음
  - 배열 매개변수는 null 또는 빈 배열로 지정해줘야 함

생성자의 조건
- 생성자의 이름은 클래스의 이름과 같아야 한다
- 생성자는 리턴값이 없다

생성자의 실행 순서
1. 연산자 new에 의해 힙에 인스턴스 생성
1. 생성자가 호출됨
1. 인스턴스 주소가 반환됨

기본 생성자
- 생성자가 하나도 없으면 컴파일러가 자동으로 `ClassName() {}`양식의 생성자를 추가한다

this
- 생성자가 다른 생성자를 호출할 때는 this()로 호출하고, 첫째 줄에서 호출해야 한다
- this는 객체 자신을 가르키는 참조 변수이다

초기화
- 클래스 변수: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

## Chapter 7 객체지향 프로그래밍 II

상속
- 상속이란 기존의 클래스를 사용하여 새로운 클래스를 작성하는 것
- 적은 양의 코드로 새로운 클래스 작성 가능
- 코드를 공통으로 관리할 수 있어 코드의 추가 및 변경에 용이

Object 클래스
- Object 클래스는 클래스 상속 계층도의 최상위에 있는 조상클래스 (JS의 prototype이랑 비슷한듯?)
- 아무것도 상속받지 않는 클래스는 자동적으로 Object 클래스를 상속함
- Object 클래스에는 모든 인스턴스가 가져야 할 기본적인 11개의 메서드가 정의되어 있음

오버라이딩
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 오버라이딩의 조건
  - 이름이 같아야 한다
  - 매개변수가 같아야 한다
  - 반환타입이 같아야 한다
  - 접근 제어자를 조상보다 좁은 범위로 변경할 수 없다
  - 조상 클래스보다 많은 예외를 선언할 수 없다

super
- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조 변수
- super와 this는 근본적으로 같다
- 그러나 super는 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 정의되어 구분해야 할 때 사용하는 게 좋다

super()
- 조상 클래스의 생성자를 호출하는 데 사용된다
- 자손 클래스의 인스턴스가 생성될 때는 먼저 조상 클래스의 생성자가 실행되어야 한다.
- 왜냐하면 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있기 때문이다.
- 따라서 컴파일러는 자동으로 `super();`를 생성자의 첫 줄에 삽입한다. (Object 클래스 제외)
- 조상 클래스의 멤버 변수는 조상의 생성자에 의해 초기화되게 하는 것이 좋다.

패키지
- 패키지란 클래스의 묶음이다
- 같은 이름의 클래스도 속한 패키지에 따라 구분될 수 있다
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다
- 패키지는 물리적으로 클래스 파일(.class)를 포함하는 하나의 디렉토리이다
- 소스 파일에 패키지를 지정하지 않은 클래스는 자동적으로 unnamed package에 속하게 된다

제어자 (modifier)
- 접근 제어자: public, protected, default, private
- 기타: static, final, abstract, native, transient, synchronized, volatile, strictfp

접근 제어자
- private: 같은 클래스 내에서만 접근 가능
- default: 같은 패키지 내에서만 접근 가능
- protected: 같은 패지키 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
- public: 접근 제한 없음

## Chapter 8 예외처리

에러의 종류
- 컴파일 에러: 컴파일 할 때 발생하는 에러
- 런타임 에러: 프로그램 실행 중 발생하는 에러
- 논리적 에러: 프로그램은 실행되지만 의도와 다르게 동작하는 것

런타임 에러의 종류
- 에러(error): 수습할 수 없는 심각한 오류(강제종료)
- 예외(exception): 수슬할 수 있는 미약한 오류

자바에서는 실행 시 발생할 수 있는 Error와 Exception을 클래스로 정의한다.

throw
- throw 키워드를 사용해서 프로그래머가 직접 예외를 발생시킬 수 있다
- 방법
  1. new 연산자로 발생시키려는 예외 클래스의 객체 생성
  1. throw 키워드를 이용해 예외 발생시킴
